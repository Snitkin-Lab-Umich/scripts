package sequence_data_454;

use seq_stats;


#sub parse_tsv_file - Takes as input: 1) tsv_file - A .tsv file generated by 454
#		    - Returns a 2D hash where the first keys are contigs and the second keys
#		      are descriptors (Length, Mean depth, GC content, Mean Quality)
sub parse_tsv_file
{
	my ($tsv_file) = @_;

	my %contigs;

	my $mean_depth = 0;
	my $total_size = 0;


	#OPEN TSV FILE, REMOVE THE HEADER LINE AND PUT THE REMAINDER IN A SCALAR
	open TSV, $tsv_file;


	#DETERMINE FORMAT OF TSV
	my $header = <TSV>;
	my @header = split /\t/, $header;
	my $num_col = @header;
	

	my @full_tsv = <TSV>;
	my $full_tsv = join "", @full_tsv;	

	close TSV;


	#SPLIT BY CONTIGS
	my @contigs_tsv = split />/, $full_tsv;
	shift @contigs_tsv;


	#GO THROUGH EACH CONTIG AND COMPUTE STATISTICS
	foreach my $contig (@contigs_tsv)
	{

		#SPLIT UP CONTIG BY LINES AND GET NAME 
		my @contig = split /\n/, $contig;

		my $contig_name = shift @contig;
		$contig_name =~ s/^([^\s]+)\s.*$/$1/;


		#GO THROUGH THE REST OF THE LINES
		my $r_base_count = &seq_stats::init_monoNucHash();
		my %base_count = %$r_base_count;

		my $length = 0;
		my $qual_total = 0;
		my $depth_total = 0;
		my $signal_total = 0;	
		my @qual;
		my @depth;


		foreach my $line (@contig)
		{

			my ($pos, $base, $qual, $uniq_depth, $align_depth, $signal, $std);

			if($num_col == 6)
			{

				($pos, $base, $qual, $align_depth, $signal, $std) = split /\t/, $line;

			}elsif($num_col == 7){

				($pos, $base, $qual, $uniq_depth, $align_depth, $signal, $std) = split /\t/, $line;

			}#end if

	
			$length ++;			

			$base_count{$base} ++;
			$qual_total += $qual;
			$depth_total += $align_depth;
			$signal_total += $signal;

			push @qual, $qual;
			push @depth, $uniq_depth;

		}#end foreach


		#SAVE RELEVENT STATS
		$contigs{$contig_name}{'SIZE'} = $length;
		$contigs{$contig_name}{'QUALITY'} = $qual_total / $length;
		$contigs{$contig_name}{'DEPTH'} = $depth_total / $length;
		$contigs{$contig_name}{'SIGNAL'} = $signal_total / $length;
		$contigs{$contig_name}{'GC'} = &seq_stats::get_GC(\%base_count);

		$contigs{$contig_name}{'DEPTH_ALL'} = join " ", @depth;
		$contigs{$contig_name}{'QUALITY_ALL'} = join " ", @qual;

		$total_size += $length;

	}#end foreach


	#GO THROUGH CONTIGS SO OVERALL DEPTH CAN BE DETERMINED
	foreach my $contig (keys %contigs)
	{

		$mean_depth += ($contigs{$contig}{'SIZE'} / $total_size) * $contigs{$contig}{'DEPTH'};

	}#end foreach


	return (\%contigs, $mean_depth);


}#end parse_tsv_file


#sub parse_tsv_depth - Takes as input: 1) tsv_file - A .tsv file generated by Newbler
#		     - Returns a 2D hash where the first key is the contig ID, the second key is the position and
#		       the value is the sequencing depth at in that contig at that position
sub parse_tsv_depth
{
	my ($tsv_file) = @_;

	my %contig_depth;


	#OPEN TSV FILE, REMOVE THE HEADER LINE AND PUT THE REMAINDER IN A SCALAR
	open TSV, $tsv_file;


	#DETERMINE FORMAT OF TSV
	my $header = <TSV>;
	my @header = split /\t/, $header;
	my $num_col = @header;
	

	my @full_tsv = <TSV>;
	my $full_tsv = join "", @full_tsv;	

	close TSV;


	#SPLIT BY CONTIGS
	my @contigs_tsv = split />/, $full_tsv;
	shift @contigs_tsv;


	#GO THROUGH EACH CONTIG AND COMPUTE STATISTICS
	foreach my $contig (@contigs_tsv)
	{

		#SPLIT UP CONTIG BY LINES AND GET NAME 
		my @contig = split /\n/, $contig;

		my $contig_name = shift @contig;
		$contig_name =~ s/^([^\s]+)\s.*$/$1/;


		#GO THROUGH THE REST OF THE LINES
		my $r_base_count = &seq_stats::init_monoNucHash();
		my %base_count = %$r_base_count;

		foreach my $line (@contig)
		{

			my ($pos, $base, $qual, $uniq_depth, $align_depth, $signal, $std);

			if($num_col == 6)
			{

				($pos, $base, $qual, $align_depth, $signal, $std) = split /\t/, $line;

			}elsif($num_col == 7){

				($pos, $base, $qual, $uniq_depth, $align_depth, $signal, $std) = split /\t/, $line;

			}#end if

	
			$contig_depth{$contig_name}{$pos} = $align_depth;

		}#end foreach

	}#end foreach


	return \%contig_depth;

}#end parse_tsv_depth


#sub get_scaffold_stats - Takes as input: 1) tsv_file		- A Newbler file describing statistics of base cals 
#								  in each contig
#					  2) scaffold_file	- A newbler file describing how scaffolds are built
#			- Returns a 2D hash where the first keys are scaffolds and the second keys
#                         are descriptors (Length, Mean depth, GC content, Mean Quality)   
sub get_scaffold_stats
{
	my ($tsv_file, $scaffold_file) = @_;

	my %scaffolds;
	my %scaffold2contig;

	#GET STATISTICS FOR EACH CONTIG
	my ($r_contigs, $mean_depth) = &parse_tsv_file($tsv_file);
	my %contigs = %$r_contigs;


	#GET CONTIG TO SCAFFOLD RELATINSHIPS
	open SCAF, $scaffold_file;

	foreach my $line (<SCAF>)
	{

		chomp $line;
		my @line = split /\t/, $line;

		my $scaffold = $line[0];
		my $contig = $line[5];

		#CHECK OF LINE IS CONTIG OR FRAGMENT, IGNORE IF FRAGMENT
		if($contig !~ /contig/)
		{

			next;

		}#end if


		#NOTE CURRENT CONTIG AND ITS LENGTH
		if( exists($scaffold2contig{$scaffold}) )
		{

			push @{$scaffold2contig{$scaffold}}, $contig;
			$scaffolds{$scaffold}{'SIZE'} += $contigs{$contig}{'SIZE'};

		}else{

			@{$scaffold2contig{$scaffold}} = ($contig);
			$scaffolds{$scaffold}{'SIZE'} = $contigs{$contig}{'SIZE'};

		}#end if


	}#end foreach


	#DETERMINE SCAFFOLD STATS
	foreach my $scaffold ( keys %scaffold2contig)
	{

		#DETERMINE THE LENGTH OF ALL CONTIGS IN THE SCAFFOLD
		foreach my $contig ( @{$scaffold2contig{$scaffold}} )
		{

			$scaffolds{$scaffold}{'QUALITY'} += ($contigs{$contig}{'SIZE'} / $scaffolds{$scaffold}{'SIZE'}) * $contigs{$contig}{'QUALITY'};
			$scaffolds{$scaffold}{'DEPTH'} += ($contigs{$contig}{'SIZE'} / $scaffolds{$scaffold}{'SIZE'}) * $contigs{$contig}{'DEPTH'};
			$scaffolds{$scaffold}{'SIGNAL'} += ($contigs{$contig}{'SIZE'} / $scaffolds{$scaffold}{'SIZE'}) * $contigs{$contig}{'SIGNAL'};
			$scaffolds{$scaffold}{'GC'} += ($contigs{$contig}{'SIZE'} / $scaffolds{$scaffold}{'SIZE'}) * $contigs{$contig}{'GC'};

		}#end foreach

	}#end foreach


	return (\%scaffolds, $mean_depth);

}#end get_scaffold_stats


#sub get_contig2scaffold - Takes as input: 1) scaffold_file - Nebler file indicating how contigs make up scaffolds
#			 - Returns a hash where the keys are contigs and the values are the scaffolds to which they belong
sub get_contig2scaffold
{
	my ($scaffold_file) = @_;

	my %contig2scaffold;


	#GO THROUGH FILE AND GET CONTIG TO SCAFFOLD RELATIONSHIPS
        open SCAF, $scaffold_file;

        foreach my $line (<SCAF>)
        {

                chomp $line;
                my @line = split /\t/, $line;

                my $scaffold = $line[0];
                my $contig = $line[5];

                #CHECK OF LINE IS CONTIG OR FRAGMENT, IGNORE IF FRAGMENT
                if($contig !~ /contig/)
                {

                        next;

                }#end if


		$contig2scaffold{$contig} = $scaffold;

        }#end foreach


	return \%contig2scaffold;

}#end get_contig2scaffold


#sub parse_454NewblerMetrics_file - Takes as input: 1) newbler_file	- A 454NewblerMetrics file
#				  - Returns a has with the keys being the name of a stat  concerning large contigs and the values being statistic
sub parse_454NewblerMetrics_file
{
	my ($newblerMetrics_file) = @_;	


	my %stats_hash;
	my $large_contig_flag = 0;
	my $scaffold_flag = 0;

	#GO THROUGH EACH LINE IN FILE AND EXTRACT RELEVENT INFO
	open IN, $newblerMetrics_file;


	foreach my $line (<IN>)
	{


        	#CHECK IF WE ARE IN CORRECT SECTION OF FILE WHERE RELEVENT STATS ARE
        	if( ($large_contig_flag == 1 || $scaffold_flag == 1) && ($line =~ /\w+/) )
        	{

        	        chomp $line;

        	        my $stat_name = $line;
        	        $stat_name  =~ s/^\s+([\w\d]+)\s+=.*$/$1/;


        	        my $stat = $line;
        	        $stat  =~ s/^.*=\s([\d\s\,\%\.]+)\;$/$1/;

        	        $stats_hash{$stat_name} = $stat;

        	}#end if


        	#CHECK FOR END OF RELEVENT SECTION
        	if( ($large_contig_flag == 1) && ($line =~ /\}/) )
        	{

        	        $large_contig_flag = 0;

        	}#end if

		if( ($scaffold_flag == 1) && ($line =~ /\}/) )
                {

                        $scaffold_flag = 0;

                }#end if



        	#CHECK FOR BEGINNING OF RELEVENT SECTION
        	if($line =~ /largeContigMetrics/)
        	{

        	        $large_contig_flag = 1;

        	}#end if

		if($line =~ /scaffoldMetrics/)
                {

                        $scaffold_flag = 1;

                }#end if



	}#end foreach


	close IN;


	return \%stats_hash;

}#end parse_454NewblerMetrics_file


1;
